import * as dal from "@/app/api/_dal/products.dal"
import type { CreateProductInput, ProductListQuery } from "@/types/api/products"
import { generateRandomImei15 } from "@/app/api/_utils/imei"
import { prisma } from "@/app/lib/db"
import { createProductAuditLog } from "@/app/api/_dal/product-audit.dal"

export async function listProducts(args: ProductListQuery, opts?: { branchId?: string }) {
  const filters = {
    search: args.search,
    status: args.status,
    productTypeId: args.productTypeId,
    productModelId: args.productModelId,
    condition: args.condition,
    availability: args.availability,
    isDefective: args.isDefective,
    branchId: opts?.branchId,
  }

  const [total, products] = await Promise.all([
    dal.countProducts(filters),
    dal.listProducts({ limit: args.limit, offset: args.offset, ...filters }),
  ])

  return {
    products,
    pagination: {
      total,
      limit: args.limit,
      offset: args.offset,
      hasMore: args.offset + args.limit < total,
    },
  }
}

export async function createProduct(
  input: CreateProductInput,
  ctx: { actorUserId: string; actorOrganizationId: string | null }
) {
  const warehouseId = await dal.getOrganizationIdBySlug("warehouse")
  if (!warehouseId) {
    throw new Error("Warehouse branch not found")
  }

  const { autoGenerateImei, imei: providedImei, ...rest } = input
  const wantsAuto = autoGenerateImei === true
  const normalizedProvidedImei = providedImei?.trim() ?? ""

  let imei = normalizedProvidedImei

  if (!imei && wantsAuto) {
    for (let attempt = 0; attempt < 10; attempt++) {
      const candidate = generateRandomImei15()
      // Extremely low collision probability, but still guard against unique constraint.
      const exists = await dal.productExistsByImei(candidate)
      if (!exists) {
        imei = candidate
        break
      }
    }
  }

  if (!imei) {
    throw new Error("IMEI/Serial is required")
  }

  // Check for duplicate IMEI before attempting to create
  const exists = await dal.productExistsByImei(imei)
  if (exists) {
    throw new Error("A product with this IMEI/Serial already exists")
  }

  const product = await dal.createProduct({
    ...rest,
    imei,
    branchId: warehouseId,
  })

  await createProductAuditLog(prisma, {
    productId: product.id,
    action: "ProductCreated",
    actorUserId: ctx.actorUserId,
    actorOrganizationId: ctx.actorOrganizationId,
    toBranchId: warehouseId,
    details: {
      imei: product.imei,
      productModelId: product.productModelId,
      condition: product.condition,
      availability: product.availability,
      isDefective: product.isDefective,
      defectNotes: product.defectNotes,
      status: product.status,
      autoGeneratedImei: wantsAuto,
    },
  })

  return product
}

export async function updateProduct(id: string, input: Record<string, unknown>) {
  return dal.updateProduct(id, input)
}

export async function deleteProduct(id: string) {
  const product = await dal.getProductById(id)
  if (!product) {
    throw new Error("Product not found")
  }

  // Check if product is associated with an invoice (either as main product or invoice item)
  const hasInvoice = product.invoice || (product.invoiceItems && product.invoiceItems.length > 0)
  if (hasInvoice) {
    throw new Error("Cannot delete product. This product has an associated invoice. Please delete or cancel the invoice first.")
  }

  return dal.deleteProduct(id)
}

export async function getProduct(id: string) {
  const found = await dal.getProductById(id)
  if (!found) {
    throw new Error("Product not found")
  }

  const invoiceIdFromInvoice = found.invoice?.id ?? null
  const invoiceItem = found.invoiceItems?.[0]
  const invoiceIdFromItem = invoiceItem?.invoiceId ?? null

  const soldInvoiceId = invoiceIdFromInvoice ?? invoiceIdFromItem
  const soldAsFreebie = invoiceItem?.isFreebie === true

  const { invoice: _invoice, invoiceItems: _invoiceItems, ...product } = found

  return {
    ...product,
    soldInvoiceId,
    soldAsFreebie,
  }
}
